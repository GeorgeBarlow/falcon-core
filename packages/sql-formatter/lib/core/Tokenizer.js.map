{"version":3,"sources":["../../src/core/Tokenizer.js"],"names":["Tokenizer","constructor","cfg","WHITESPACE_REGEX","NUMBER_REGEX","OPERATOR_REGEX","BLOCK_COMMENT_REGEX","LINE_COMMENT_REGEX","createLineCommentRegex","lineCommentTypes","RESERVED_TOPLEVEL_REGEX","createReservedWordRegex","reservedToplevelWords","RESERVED_NEWLINE_REGEX","reservedNewlineWords","RESERVED_PLAIN_REGEX","reservedWords","WORD_REGEX","createWordRegex","specialWordChars","STRING_REGEX","createStringRegex","stringTypes","OPEN_PAREN_REGEX","createParenRegex","openParens","CLOSE_PAREN_REGEX","closeParens","INDEXED_PLACEHOLDER_REGEX","createPlaceholderRegex","indexedPlaceholderTypes","IDENT_NAMED_PLACEHOLDER_REGEX","namedPlaceholderTypes","STRING_NAMED_PLACEHOLDER_REGEX","createStringPattern","RegExp","map","c","join","reservedWordsPattern","replace","specialChars","patterns","t","parens","p","types","pattern","typesRegex","escapeRegExp","tokenize","input","tokens","token","length","getNextToken","substring","value","push","previousToken","getWhitespaceToken","getCommentToken","getStringToken","getOpenParenToken","getCloseParenToken","getPlaceholderToken","getNumberToken","getReservedWordToken","getWordToken","getOperatorToken","getTokenOnFirstMatch","type","tokenTypes","WHITESPACE","regex","getLineCommentToken","getBlockCommentToken","LINE_COMMENT","BLOCK_COMMENT","STRING","OPEN_PAREN","CLOSE_PAREN","getIdentNamedPlaceholderToken","getStringNamedPlaceholderToken","getIndexedPlaceholderToken","getPlaceholderTokenWithKey","parseKey","v","slice","getEscapedPlaceholderKey","key","quoteChar","PLACEHOLDER","NUMBER","OPERATOR","getToplevelReservedToken","getNewlineReservedToken","getPlainReservedToken","RESERVED_TOPLEVEL","RESERVED_NEWLINE","RESERVED","WORD","matches","match"],"mappings":"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","file":"Tokenizer.js","sourcesContent":["import isEmpty from 'lodash/isEmpty';\nimport escapeRegExp from 'lodash/escapeRegExp';\nimport tokenTypes from './tokenTypes';\n\nexport default class Tokenizer {\n  /**\n   * @param {Object} cfg\n   *  @param {String[]} cfg.reservedWords Reserved words in SQL\n   *  @param {String[]} cfg.reservedToplevelWords Words that are set to new line separately\n   *  @param {String[]} cfg.reservedNewlineWords Words that are set to newline\n   *  @param {String[]} cfg.stringTypes String types to enable: \"\", '', ``, [], N''\n   *  @param {String[]} cfg.openParens Opening parentheses to enable, like (, [\n   *  @param {String[]} cfg.closeParens Closing parentheses to enable, like ), ]\n   *  @param {String[]} cfg.indexedPlaceholderTypes Prefixes for indexed placeholders, like ?\n   *  @param {String[]} cfg.namedPlaceholderTypes Prefixes for named placeholders, like @ and :\n   *  @param {String[]} cfg.lineCommentTypes Line comments to enable, like # and --\n   *  @param {String[]} cfg.specialWordChars Special chars that can be found inside of words, like @ and #\n   */\n  constructor(cfg) {\n    this.WHITESPACE_REGEX = /^(\\s+)/;\n    this.NUMBER_REGEX = /^((-\\s*)?[0-9]+(\\.[0-9]+)?|0x[0-9a-fA-F]+|0b[01]+)\\b/;\n    this.OPERATOR_REGEX = /^(!=|<>|==|<=|>=|!<|!>|\\|\\||::|->>|->|~~\\*|~~|!~~\\*|!~~|~\\*|!~\\*|!~|.)/;\n\n    this.BLOCK_COMMENT_REGEX = /^(\\/\\*[^]*?(?:\\*\\/|$))/;\n    this.LINE_COMMENT_REGEX = this.createLineCommentRegex(cfg.lineCommentTypes);\n\n    this.RESERVED_TOPLEVEL_REGEX = this.createReservedWordRegex(\n      cfg.reservedToplevelWords\n    );\n    this.RESERVED_NEWLINE_REGEX = this.createReservedWordRegex(\n      cfg.reservedNewlineWords\n    );\n    this.RESERVED_PLAIN_REGEX = this.createReservedWordRegex(cfg.reservedWords);\n\n    this.WORD_REGEX = this.createWordRegex(cfg.specialWordChars);\n    this.STRING_REGEX = this.createStringRegex(cfg.stringTypes);\n\n    this.OPEN_PAREN_REGEX = this.createParenRegex(cfg.openParens);\n    this.CLOSE_PAREN_REGEX = this.createParenRegex(cfg.closeParens);\n\n    this.INDEXED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(\n      cfg.indexedPlaceholderTypes,\n      '[0-9]*'\n    );\n    this.IDENT_NAMED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(\n      cfg.namedPlaceholderTypes,\n      '[a-zA-Z0-9._$]+'\n    );\n    this.STRING_NAMED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(\n      cfg.namedPlaceholderTypes,\n      this.createStringPattern(cfg.stringTypes)\n    );\n  }\n\n  createLineCommentRegex(lineCommentTypes) {\n    return new RegExp(\n      `^((?:${lineCommentTypes\n        .map(c => escapeRegExp(c))\n        .join('|')}).*?(?:\\n|$))`\n    );\n  }\n\n  createReservedWordRegex(reservedWords) {\n    const reservedWordsPattern = reservedWords.join('|').replace(/ /g, '\\\\s+');\n    return new RegExp(`^(${reservedWordsPattern})\\\\b`, 'i');\n  }\n\n  createWordRegex(specialChars = []) {\n    return new RegExp(`^([\\\\w${specialChars.join('')}]+)`);\n  }\n\n  createStringRegex(stringTypes) {\n    return new RegExp(`^(${this.createStringPattern(stringTypes)})`);\n  }\n\n  // This enables the following string patterns:\n  // 1. backtick quoted string using `` to escape\n  // 2. square bracket quoted string (SQL Server) using ]] to escape\n  // 3. double quoted string using \"\" or \\\" to escape\n  // 4. single quoted string using '' or \\' to escape\n  // 5. national character quoted string using N'' or N\\' to escape\n  createStringPattern(stringTypes) {\n    const patterns = {\n      '``': '((`[^`]*($|`))+)',\n      '[]': '((\\\\[[^\\\\]]*($|\\\\]))(\\\\][^\\\\]]*($|\\\\]))*)',\n      '\"\"': '((\"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*(\"|$))+)',\n      \"''\": \"(('[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*('|$))+)\",\n      \"N''\": \"((N'[^N'\\\\\\\\]*(?:\\\\\\\\.[^N'\\\\\\\\]*)*('|$))+)\"\n    };\n\n    return stringTypes.map(t => patterns[t]).join('|');\n  }\n\n  createParenRegex(parens) {\n    return new RegExp(`^(${parens.map(p => escapeRegExp(p)).join('|')})`);\n  }\n\n  createPlaceholderRegex(types, pattern) {\n    if (isEmpty(types)) {\n      return false;\n    }\n    const typesRegex = types.map(escapeRegExp).join('|');\n\n    return new RegExp(`^((?:${typesRegex})(?:${pattern}))`);\n  }\n\n  /**\n   * Takes a SQL string and breaks it into tokens.\n   * Each token is an object with type and value.\n   *\n   * @param {String} input The SQL string\n   * @return {Object[]} tokens An array of tokens.\n   *  @return {String} token.type\n   *  @return {String} token.value\n   */\n  tokenize(input) {\n    const tokens = [];\n    let token;\n\n    // Keep processing the string until it is empty\n    while (input.length) {\n      // Get the next token and the token type\n      token = this.getNextToken(input, token);\n      // Advance the string\n      input = input.substring(token.value.length);\n\n      tokens.push(token);\n    }\n    return tokens;\n  }\n\n  getNextToken(input, previousToken) {\n    return (\n      this.getWhitespaceToken(input) ||\n      this.getCommentToken(input) ||\n      this.getStringToken(input) ||\n      this.getOpenParenToken(input) ||\n      this.getCloseParenToken(input) ||\n      this.getPlaceholderToken(input) ||\n      this.getNumberToken(input) ||\n      this.getReservedWordToken(input, previousToken) ||\n      this.getWordToken(input) ||\n      this.getOperatorToken(input)\n    );\n  }\n\n  getWhitespaceToken(input) {\n    return this.getTokenOnFirstMatch({\n      input,\n      type: tokenTypes.WHITESPACE,\n      regex: this.WHITESPACE_REGEX\n    });\n  }\n\n  getCommentToken(input) {\n    return this.getLineCommentToken(input) || this.getBlockCommentToken(input);\n  }\n\n  getLineCommentToken(input) {\n    return this.getTokenOnFirstMatch({\n      input,\n      type: tokenTypes.LINE_COMMENT,\n      regex: this.LINE_COMMENT_REGEX\n    });\n  }\n\n  getBlockCommentToken(input) {\n    return this.getTokenOnFirstMatch({\n      input,\n      type: tokenTypes.BLOCK_COMMENT,\n      regex: this.BLOCK_COMMENT_REGEX\n    });\n  }\n\n  getStringToken(input) {\n    return this.getTokenOnFirstMatch({\n      input,\n      type: tokenTypes.STRING,\n      regex: this.STRING_REGEX\n    });\n  }\n\n  getOpenParenToken(input) {\n    return this.getTokenOnFirstMatch({\n      input,\n      type: tokenTypes.OPEN_PAREN,\n      regex: this.OPEN_PAREN_REGEX\n    });\n  }\n\n  getCloseParenToken(input) {\n    return this.getTokenOnFirstMatch({\n      input,\n      type: tokenTypes.CLOSE_PAREN,\n      regex: this.CLOSE_PAREN_REGEX\n    });\n  }\n\n  getPlaceholderToken(input) {\n    return (\n      this.getIdentNamedPlaceholderToken(input) ||\n      this.getStringNamedPlaceholderToken(input) ||\n      this.getIndexedPlaceholderToken(input)\n    );\n  }\n\n  getIdentNamedPlaceholderToken(input) {\n    return this.getPlaceholderTokenWithKey({\n      input,\n      regex: this.IDENT_NAMED_PLACEHOLDER_REGEX,\n      parseKey: v => v.slice(1)\n    });\n  }\n\n  getStringNamedPlaceholderToken(input) {\n    return this.getPlaceholderTokenWithKey({\n      input,\n      regex: this.STRING_NAMED_PLACEHOLDER_REGEX,\n      parseKey: v =>\n        this.getEscapedPlaceholderKey({\n          key: v.slice(2, -1),\n          quoteChar: v.slice(-1)\n        })\n    });\n  }\n\n  getIndexedPlaceholderToken(input) {\n    return this.getPlaceholderTokenWithKey({\n      input,\n      regex: this.INDEXED_PLACEHOLDER_REGEX,\n      parseKey: v => v.slice(1)\n    });\n  }\n\n  getPlaceholderTokenWithKey({ input, regex, parseKey }) {\n    const token = this.getTokenOnFirstMatch({\n      input,\n      regex,\n      type: tokenTypes.PLACEHOLDER\n    });\n    if (token) {\n      token.key = parseKey(token.value);\n    }\n    return token;\n  }\n\n  getEscapedPlaceholderKey({ key, quoteChar }) {\n    return key.replace(\n      new RegExp(escapeRegExp('\\\\') + quoteChar, 'g'),\n      quoteChar\n    );\n  }\n\n  // Decimal, binary, or hex numbers\n  getNumberToken(input) {\n    return this.getTokenOnFirstMatch({\n      input,\n      type: tokenTypes.NUMBER,\n      regex: this.NUMBER_REGEX\n    });\n  }\n\n  // Punctuation and symbols\n  getOperatorToken(input) {\n    return this.getTokenOnFirstMatch({\n      input,\n      type: tokenTypes.OPERATOR,\n      regex: this.OPERATOR_REGEX\n    });\n  }\n\n  getReservedWordToken(input, previousToken) {\n    // A reserved word cannot be preceded by a \".\"\n    // this makes it so in \"mytable.from\", \"from\" is not considered a reserved word\n    if (previousToken && previousToken.value && previousToken.value === '.') {\n      return;\n    }\n    return (\n      this.getToplevelReservedToken(input) ||\n      this.getNewlineReservedToken(input) ||\n      this.getPlainReservedToken(input)\n    );\n  }\n\n  getToplevelReservedToken(input) {\n    return this.getTokenOnFirstMatch({\n      input,\n      type: tokenTypes.RESERVED_TOPLEVEL,\n      regex: this.RESERVED_TOPLEVEL_REGEX\n    });\n  }\n\n  getNewlineReservedToken(input) {\n    return this.getTokenOnFirstMatch({\n      input,\n      type: tokenTypes.RESERVED_NEWLINE,\n      regex: this.RESERVED_NEWLINE_REGEX\n    });\n  }\n\n  getPlainReservedToken(input) {\n    return this.getTokenOnFirstMatch({\n      input,\n      type: tokenTypes.RESERVED,\n      regex: this.RESERVED_PLAIN_REGEX\n    });\n  }\n\n  getWordToken(input) {\n    return this.getTokenOnFirstMatch({\n      input,\n      type: tokenTypes.WORD,\n      regex: this.WORD_REGEX\n    });\n  }\n\n  getTokenOnFirstMatch({ input, type, regex }) {\n    const matches = input.match(regex);\n\n    if (matches) {\n      return { type, value: matches[1] };\n    }\n  }\n}\n"]}