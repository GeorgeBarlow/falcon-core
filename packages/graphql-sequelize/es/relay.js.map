{"version":3,"sources":["../src/relay.js"],"names":["fromGlobalId","connectionFromArray","nodeDefinitions","connectionDefinitions","connectionArgs","GraphQLList","base64","unbase64","_","simplifyAST","NodeTypeMapper","constructor","map","mapTypes","types","Object","keys","forEach","k","v","type","item","idFetcher","sequelize","nodeTypeMapper","globalId","context","id","nodeType","resolve","res","Promise","__graphqlType__","model","models","find","findById","typeResolver","obj","Model","options","name","singular","_modelOptions","Error","isConnection","endsWith","handleConnection","values","args","sequelizeNodeInterface","nodeObjects","connectionType","_fields","edges","ofType","node","sequelizeConnection","target","targetMaybeThunk","orderBy","orderByEnum","before","after","connectionFields","edgeFields","where","edgeType","SEPERATOR","PREFIX","result","$connectionArgs","orderByAttribute","orderAttr","source","info","orderByDirection","orderDirection","last","indexOf","replace","toCursor","index","get","primaryKeyAttribute","fromCursor","cursor","substring","length","split","argsToWhere","undefined","each","value","key","assign","resolveEdge","queriedCursor","startIndex","Number","$resolver","require","list","first","limit","parseInt","_values","_nameLookup","orderAttribute","order","push","attributes","some","attribute","dialect","literal","offset","uniq","idx","firstEdge","lastEdge","fullCount","dataValues","full_count","count","associationType","manyFromSource","hasNextPage","hasPreviousPage","pageInfo","startCursor","endCursor","resolver","fieldNodes","fieldASTs","fields"],"mappings":"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","file":"relay.js","sourcesContent":["import {\n  fromGlobalId,\n  connectionFromArray,\n  nodeDefinitions,\n  connectionDefinitions,\n  connectionArgs\n} from 'graphql-relay';\n\nimport {\n  GraphQLList\n} from 'graphql';\n\nimport {\n  base64,\n  unbase64,\n} from './base64.js';\n\nimport _ from 'lodash';\nimport simplifyAST from './simplifyAST';\n\nexport class NodeTypeMapper {\n  constructor() {\n    this.map = { };\n  }\n\n  mapTypes(types) {\n    Object.keys(types).forEach((k) => {\n      let v = types[k];\n      this.map[k] = v.type\n        ? v\n        : { type: v };\n    });\n  }\n\n  item(type) {\n    return this.map[type];\n  }\n}\n\nexport function idFetcher(sequelize, nodeTypeMapper) {\n  return async (globalId, context) => {\n    const {type, id} = fromGlobalId(globalId);\n\n    const nodeType = nodeTypeMapper.item(type);\n    if (nodeType && typeof nodeType.resolve === 'function') {\n      const res = await Promise.resolve(nodeType.resolve(globalId, context));\n      if (res) res.__graphqlType__ = type;\n      return res;\n    }\n\n    const model = Object.keys(sequelize.models).find(model => model === type);\n    return model\n      ? sequelize.models[model].findById(id)\n      : nodeType\n        ? nodeType.type\n        : null;\n  };\n}\n\nexport function typeResolver(nodeTypeMapper) {\n  return obj => {\n    var type = obj.__graphqlType__\n               || (obj.Model\n                 ? obj.Model.options.name.singular\n                 : obj._modelOptions\n                 ? obj._modelOptions.name.singular\n                 : obj.name);\n\n    if (!type) {\n      throw new Error(`Unable to determine type of ${ typeof obj }. ` +\n        `Either specify a resolve function in 'NodeTypeMapper' object, or specify '__graphqlType__' property on object.`);\n    }\n\n    const nodeType = nodeTypeMapper.item(type);\n    return nodeType && nodeType.type || null;\n  };\n}\n\nexport function isConnection(type) {\n  return typeof type.name !== 'undefined' && type.name.endsWith('Connection');\n}\n\nexport function handleConnection(values, args) {\n  return connectionFromArray(values, args);\n}\n\nexport function sequelizeNodeInterface(sequelize) {\n  let nodeTypeMapper = new NodeTypeMapper();\n  const nodeObjects = nodeDefinitions(\n    idFetcher(sequelize, nodeTypeMapper),\n    typeResolver(nodeTypeMapper)\n  );\n\n  return {\n    nodeTypeMapper,\n    ...nodeObjects\n  };\n}\n\nexport function nodeType(connectionType) {\n  return connectionType._fields.edges.type.ofType._fields.node.type;\n}\n\nexport function sequelizeConnection({\n  name,\n  nodeType,\n  target: targetMaybeThunk,\n  orderBy: orderByEnum,\n  before,\n  after,\n  connectionFields,\n  edgeFields,\n  where\n}) {\n  const {\n    edgeType,\n    connectionType\n  } = connectionDefinitions({\n    name,\n    nodeType,\n    connectionFields,\n    edgeFields\n  });\n\n  const SEPERATOR = '$';\n  const PREFIX = 'arrayconnection' + SEPERATOR;\n\n  before = before || ((options) => options);\n  after = after || ((result) => result);\n\n  let $connectionArgs = {\n    ...connectionArgs\n  };\n\n  if (orderByEnum) {\n    $connectionArgs.orderBy = {\n      type: new GraphQLList(orderByEnum)\n    };\n  }\n\n  let orderByAttribute = function (orderAttr, {source, args, context, info}) {\n    return typeof orderAttr === 'function' ? orderAttr(source, args, context, info) : orderAttr;\n  };\n\n  let orderByDirection = function (orderDirection, args) {\n    if (args.last) {\n      return orderDirection.indexOf('ASC') >= 0\n              ? orderDirection.replace('ASC', 'DESC')\n              : orderDirection.replace('DESC', 'ASC');\n    }\n    return orderDirection;\n  };\n\n  /**\n   * Creates a cursor given a item returned from the Database\n   * @param  {Object}   item   sequelize model instance\n   * @param  {Integer}  index  the index of this item within the results, 0 indexed\n   * @return {String}          The Base64 encoded cursor string\n   */\n  let toCursor = function (item, index) {\n    let id = item.get(item.constructor ? item.constructor.primaryKeyAttribute : item.Model.primaryKeyAttribute);\n    return base64(PREFIX + id + SEPERATOR + index);\n  };\n\n  /**\n   * Decode a cursor into its component parts\n   * @param  {String} cursor Base64 encoded cursor\n   * @return {Object}        Object containing ID and index\n   */\n  let fromCursor = function (cursor) {\n    cursor = unbase64(cursor);\n    cursor = cursor.substring(PREFIX.length, cursor.length);\n    let [id, index] = cursor.split(SEPERATOR);\n\n    return {\n      id,\n      index\n    };\n  };\n\n  let argsToWhere = function (args) {\n    let result = {};\n\n    if (where === undefined) return result;\n\n    _.each(args, (value, key) => {\n      if (key in $connectionArgs) return;\n      _.assign(result, where(key, value, result));\n    });\n\n    return result;\n  };\n\n  let resolveEdge = function (item, index, queriedCursor, args = {}, source) {\n    let startIndex = null;\n    if (queriedCursor) startIndex = Number(queriedCursor.index);\n    if (startIndex !== null) {\n      startIndex++;\n    } else {\n      startIndex = 0;\n    }\n\n    return {\n      cursor: toCursor(item, index + startIndex),\n      node: item,\n      source: source\n    };\n  };\n\n  let $resolver = require('./resolver')(targetMaybeThunk, {\n    handleConnection: false,\n    list: true,\n    before: function (options, args, context, info) {\n      const target = info.target;\n      const model = target.target ? target.target : target;\n\n      if (args.first || args.last) {\n        options.limit = parseInt(args.first || args.last, 10);\n      }\n\n      let orderBy = args.orderBy ? args.orderBy :\n                    orderByEnum ? [orderByEnum._values[0].value] :\n                    [[model.primaryKeyAttribute, 'ASC']];\n\n      if (orderByEnum && typeof orderBy === 'string') {\n        orderBy = [orderByEnum._nameLookup[args.orderBy].value];\n      }\n\n      let orderAttribute = orderByAttribute(orderBy[0][0], {\n        source: info.source,\n        args,\n        context,\n        info\n      });\n      let orderDirection = orderByDirection(orderBy[0][1], args);\n\n      options.order = [\n        [orderAttribute, orderDirection]\n      ];\n\n      if (orderAttribute !== model.primaryKeyAttribute) {\n        options.order.push([model.primaryKeyAttribute, orderByDirection('ASC', args)]);\n      }\n\n      if (typeof orderAttribute === 'string') {\n        options.attributes.push(orderAttribute);\n      }\n\n      if (options.limit && !options.attributes.some(attribute => attribute.length === 2 && attribute[1] === 'full_count')) {\n        if (model.sequelize.dialect.name === 'postgres') {\n          options.attributes.push([\n            model.sequelize.literal('COUNT(*) OVER()'),\n            'full_count'\n          ]);\n        } else if (model.sequelize.dialect.name === 'mssql') {\n          options.attributes.push([\n            model.sequelize.literal('COUNT(1) OVER()'),\n            'full_count'\n          ]);\n        }\n      }\n\n      options.where = argsToWhere(args);\n\n      if (args.after || args.before) {\n        let cursor = fromCursor(args.after || args.before);\n        let startIndex = Number(cursor.index);\n\n        if (startIndex >= 0) options.offset = startIndex + 1;\n      }\n      options.attributes = _.uniq(options.attributes);\n      return before(options, args, context, info);\n    },\n    after: async function (values, args, context, info) {\n      const {\n        source,\n        target\n      } = info;\n\n      var cursor = null;\n\n      if (args.after || args.before) {\n        cursor = fromCursor(args.after || args.before);\n      }\n\n      let edges = values.map((value, idx) => {\n        return resolveEdge(value, idx, cursor, args, source);\n      });\n\n      let firstEdge = edges[0];\n      let lastEdge = edges[edges.length - 1];\n      let fullCount = values[0] && values[0].dataValues.full_count && parseInt(values[0].dataValues.full_count, 10);\n\n      if (!values[0]) {\n        fullCount = 0;\n      }\n\n      if ((args.first || args.last) && (fullCount === null || fullCount === undefined)) {\n        // In case of `OVER()` is not available, we need to get the full count from a second query.\n        const options = await Promise.resolve(before({\n          where: argsToWhere(args)\n        }, args, context, info));\n\n        if (target.count) {\n          if (target.associationType) {\n            fullCount = await target.count(source, options);\n          } else {\n            fullCount = await target.count(options);\n          }\n        } else {\n          fullCount = await target.manyFromSource.count(source, options);\n        }\n      }\n\n      let hasNextPage = false;\n      let hasPreviousPage = false;\n      if (args.first || args.last) {\n        const count = parseInt(args.first || args.last, 10);\n        let index = cursor ? Number(cursor.index) : null;\n        if (index !== null) {\n          index++;\n        } else {\n          index = 0;\n        }\n\n        hasNextPage = index + 1 + count <= fullCount;\n        hasPreviousPage = index - count >= 0;\n\n        if (args.last) {\n          [hasNextPage, hasPreviousPage] = [hasPreviousPage, hasNextPage];\n        }\n      }\n\n      return after({\n        source,\n        args,\n        where: argsToWhere(args),\n        edges,\n        pageInfo: {\n          startCursor: firstEdge ? firstEdge.cursor : null,\n          endCursor: lastEdge ? lastEdge.cursor : null,\n          hasNextPage: hasNextPage,\n          hasPreviousPage: hasPreviousPage\n        },\n        fullCount\n      }, args, context, info);\n    }\n  });\n\n  let resolver = (source, args, context, info) => {\n    var fieldNodes = info.fieldASTs || info.fieldNodes;\n    if (simplifyAST(fieldNodes[0], info).fields.edges) {\n      return $resolver(source, args, context, info);\n    }\n\n    return after({\n      source,\n      args,\n      where: argsToWhere(args)\n    }, args, context, info);\n  };\n\n  return {\n    connectionType,\n    edgeType,\n    nodeType,\n    resolveEdge,\n    connectionArgs: $connectionArgs,\n    resolve: resolver\n  };\n}\n"]}