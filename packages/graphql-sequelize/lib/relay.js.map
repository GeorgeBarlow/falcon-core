{"version":3,"sources":["../src/relay.js"],"names":["idFetcher","typeResolver","isConnection","handleConnection","sequelizeNodeInterface","nodeType","sequelizeConnection","NodeTypeMapper","constructor","map","mapTypes","types","Object","keys","forEach","k","v","type","item","sequelize","nodeTypeMapper","globalId","context","id","resolve","res","Promise","__graphqlType__","model","models","find","findById","obj","Model","options","name","singular","_modelOptions","Error","endsWith","values","args","nodeObjects","connectionType","_fields","edges","ofType","node","target","targetMaybeThunk","orderBy","orderByEnum","before","after","connectionFields","edgeFields","where","edgeType","SEPERATOR","PREFIX","result","$connectionArgs","connectionArgs","GraphQLList","orderByAttribute","orderAttr","source","info","orderByDirection","orderDirection","last","indexOf","replace","toCursor","index","get","primaryKeyAttribute","fromCursor","cursor","substring","length","split","argsToWhere","undefined","_","each","value","key","assign","resolveEdge","queriedCursor","startIndex","Number","$resolver","require","list","first","limit","parseInt","_values","_nameLookup","orderAttribute","order","push","attributes","some","attribute","dialect","literal","offset","uniq","idx","firstEdge","lastEdge","fullCount","dataValues","full_count","count","associationType","manyFromSource","hasNextPage","hasPreviousPage","pageInfo","startCursor","endCursor","resolver","fieldNodes","fieldASTs","fields"],"mappings":"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","file":"relay.js","sourcesContent":["import {\n  fromGlobalId,\n  connectionFromArray,\n  nodeDefinitions,\n  connectionDefinitions,\n  connectionArgs\n} from 'graphql-relay';\n\nimport {\n  GraphQLList\n} from 'graphql';\n\nimport {\n  base64,\n  unbase64,\n} from './base64.js';\n\nimport _ from 'lodash';\nimport simplifyAST from './simplifyAST';\n\nexport class NodeTypeMapper {\n  constructor() {\n    this.map = { };\n  }\n\n  mapTypes(types) {\n    Object.keys(types).forEach((k) => {\n      let v = types[k];\n      this.map[k] = v.type\n        ? v\n        : { type: v };\n    });\n  }\n\n  item(type) {\n    return this.map[type];\n  }\n}\n\nexport function idFetcher(sequelize, nodeTypeMapper) {\n  return async (globalId, context) => {\n    const {type, id} = fromGlobalId(globalId);\n\n    const nodeType = nodeTypeMapper.item(type);\n    if (nodeType && typeof nodeType.resolve === 'function') {\n      const res = await Promise.resolve(nodeType.resolve(globalId, context));\n      if (res) res.__graphqlType__ = type;\n      return res;\n    }\n\n    const model = Object.keys(sequelize.models).find(model => model === type);\n    return model\n      ? sequelize.models[model].findById(id)\n      : nodeType\n        ? nodeType.type\n        : null;\n  };\n}\n\nexport function typeResolver(nodeTypeMapper) {\n  return obj => {\n    var type = obj.__graphqlType__\n               || (obj.Model\n                 ? obj.Model.options.name.singular\n                 : obj._modelOptions\n                 ? obj._modelOptions.name.singular\n                 : obj.name);\n\n    if (!type) {\n      throw new Error(`Unable to determine type of ${ typeof obj }. ` +\n        `Either specify a resolve function in 'NodeTypeMapper' object, or specify '__graphqlType__' property on object.`);\n    }\n\n    const nodeType = nodeTypeMapper.item(type);\n    return nodeType && nodeType.type || null;\n  };\n}\n\nexport function isConnection(type) {\n  return typeof type.name !== 'undefined' && type.name.endsWith('Connection');\n}\n\nexport function handleConnection(values, args) {\n  return connectionFromArray(values, args);\n}\n\nexport function sequelizeNodeInterface(sequelize) {\n  let nodeTypeMapper = new NodeTypeMapper();\n  const nodeObjects = nodeDefinitions(\n    idFetcher(sequelize, nodeTypeMapper),\n    typeResolver(nodeTypeMapper)\n  );\n\n  return {\n    nodeTypeMapper,\n    ...nodeObjects\n  };\n}\n\nexport function nodeType(connectionType) {\n  return connectionType._fields.edges.type.ofType._fields.node.type;\n}\n\nexport function sequelizeConnection({\n  name,\n  nodeType,\n  target: targetMaybeThunk,\n  orderBy: orderByEnum,\n  before,\n  after,\n  connectionFields,\n  edgeFields,\n  where\n}) {\n  const {\n    edgeType,\n    connectionType\n  } = connectionDefinitions({\n    name,\n    nodeType,\n    connectionFields,\n    edgeFields\n  });\n\n  const SEPERATOR = '$';\n  const PREFIX = 'arrayconnection' + SEPERATOR;\n\n  before = before || ((options) => options);\n  after = after || ((result) => result);\n\n  let $connectionArgs = {\n    ...connectionArgs\n  };\n\n  if (orderByEnum) {\n    $connectionArgs.orderBy = {\n      type: new GraphQLList(orderByEnum)\n    };\n  }\n\n  let orderByAttribute = function (orderAttr, {source, args, context, info}) {\n    return typeof orderAttr === 'function' ? orderAttr(source, args, context, info) : orderAttr;\n  };\n\n  let orderByDirection = function (orderDirection, args) {\n    if (args.last) {\n      return orderDirection.indexOf('ASC') >= 0\n              ? orderDirection.replace('ASC', 'DESC')\n              : orderDirection.replace('DESC', 'ASC');\n    }\n    return orderDirection;\n  };\n\n  /**\n   * Creates a cursor given a item returned from the Database\n   * @param  {Object}   item   sequelize model instance\n   * @param  {Integer}  index  the index of this item within the results, 0 indexed\n   * @return {String}          The Base64 encoded cursor string\n   */\n  let toCursor = function (item, index) {\n    let id = item.get(item.constructor ? item.constructor.primaryKeyAttribute : item.Model.primaryKeyAttribute);\n    return base64(PREFIX + id + SEPERATOR + index);\n  };\n\n  /**\n   * Decode a cursor into its component parts\n   * @param  {String} cursor Base64 encoded cursor\n   * @return {Object}        Object containing ID and index\n   */\n  let fromCursor = function (cursor) {\n    cursor = unbase64(cursor);\n    cursor = cursor.substring(PREFIX.length, cursor.length);\n    let [id, index] = cursor.split(SEPERATOR);\n\n    return {\n      id,\n      index\n    };\n  };\n\n  let argsToWhere = function (args) {\n    let result = {};\n\n    if (where === undefined) return result;\n\n    _.each(args, (value, key) => {\n      if (key in $connectionArgs) return;\n      _.assign(result, where(key, value, result));\n    });\n\n    return result;\n  };\n\n  let resolveEdge = function (item, index, queriedCursor, args = {}, source) {\n    let startIndex = null;\n    if (queriedCursor) startIndex = Number(queriedCursor.index);\n    if (startIndex !== null) {\n      startIndex++;\n    } else {\n      startIndex = 0;\n    }\n\n    return {\n      cursor: toCursor(item, index + startIndex),\n      node: item,\n      source: source\n    };\n  };\n\n  let $resolver = require('./resolver')(targetMaybeThunk, {\n    handleConnection: false,\n    list: true,\n    before: function (options, args, context, info) {\n      const target = info.target;\n      const model = target.target ? target.target : target;\n\n      if (args.first || args.last) {\n        options.limit = parseInt(args.first || args.last, 10);\n      }\n\n      let orderBy = args.orderBy ? args.orderBy :\n                    orderByEnum ? [orderByEnum._values[0].value] :\n                    [[model.primaryKeyAttribute, 'ASC']];\n\n      if (orderByEnum && typeof orderBy === 'string') {\n        orderBy = [orderByEnum._nameLookup[args.orderBy].value];\n      }\n\n      let orderAttribute = orderByAttribute(orderBy[0][0], {\n        source: info.source,\n        args,\n        context,\n        info\n      });\n      let orderDirection = orderByDirection(orderBy[0][1], args);\n\n      options.order = [\n        [orderAttribute, orderDirection]\n      ];\n\n      if (orderAttribute !== model.primaryKeyAttribute) {\n        options.order.push([model.primaryKeyAttribute, orderByDirection('ASC', args)]);\n      }\n\n      if (typeof orderAttribute === 'string') {\n        options.attributes.push(orderAttribute);\n      }\n\n      if (options.limit && !options.attributes.some(attribute => attribute.length === 2 && attribute[1] === 'full_count')) {\n        if (model.sequelize.dialect.name === 'postgres') {\n          options.attributes.push([\n            model.sequelize.literal('COUNT(*) OVER()'),\n            'full_count'\n          ]);\n        } else if (model.sequelize.dialect.name === 'mssql') {\n          options.attributes.push([\n            model.sequelize.literal('COUNT(1) OVER()'),\n            'full_count'\n          ]);\n        }\n      }\n\n      options.where = argsToWhere(args);\n\n      if (args.after || args.before) {\n        let cursor = fromCursor(args.after || args.before);\n        let startIndex = Number(cursor.index);\n\n        if (startIndex >= 0) options.offset = startIndex + 1;\n      }\n      options.attributes = _.uniq(options.attributes);\n      return before(options, args, context, info);\n    },\n    after: async function (values, args, context, info) {\n      const {\n        source,\n        target\n      } = info;\n\n      var cursor = null;\n\n      if (args.after || args.before) {\n        cursor = fromCursor(args.after || args.before);\n      }\n\n      let edges = values.map((value, idx) => {\n        return resolveEdge(value, idx, cursor, args, source);\n      });\n\n      let firstEdge = edges[0];\n      let lastEdge = edges[edges.length - 1];\n      let fullCount = values[0] && values[0].dataValues.full_count && parseInt(values[0].dataValues.full_count, 10);\n\n      if (!values[0]) {\n        fullCount = 0;\n      }\n\n      if ((args.first || args.last) && (fullCount === null || fullCount === undefined)) {\n        // In case of `OVER()` is not available, we need to get the full count from a second query.\n        const options = await Promise.resolve(before({\n          where: argsToWhere(args)\n        }, args, context, info));\n\n        if (target.count) {\n          if (target.associationType) {\n            fullCount = await target.count(source, options);\n          } else {\n            fullCount = await target.count(options);\n          }\n        } else {\n          fullCount = await target.manyFromSource.count(source, options);\n        }\n      }\n\n      let hasNextPage = false;\n      let hasPreviousPage = false;\n      if (args.first || args.last) {\n        const count = parseInt(args.first || args.last, 10);\n        let index = cursor ? Number(cursor.index) : null;\n        if (index !== null) {\n          index++;\n        } else {\n          index = 0;\n        }\n\n        hasNextPage = index + 1 + count <= fullCount;\n        hasPreviousPage = index - count >= 0;\n\n        if (args.last) {\n          [hasNextPage, hasPreviousPage] = [hasPreviousPage, hasNextPage];\n        }\n      }\n\n      return after({\n        source,\n        args,\n        where: argsToWhere(args),\n        edges,\n        pageInfo: {\n          startCursor: firstEdge ? firstEdge.cursor : null,\n          endCursor: lastEdge ? lastEdge.cursor : null,\n          hasNextPage: hasNextPage,\n          hasPreviousPage: hasPreviousPage\n        },\n        fullCount\n      }, args, context, info);\n    }\n  });\n\n  let resolver = (source, args, context, info) => {\n    var fieldNodes = info.fieldASTs || info.fieldNodes;\n    if (simplifyAST(fieldNodes[0], info).fields.edges) {\n      return $resolver(source, args, context, info);\n    }\n\n    return after({\n      source,\n      args,\n      where: argsToWhere(args)\n    }, args, context, info);\n  };\n\n  return {\n    connectionType,\n    edgeType,\n    nodeType,\n    resolveEdge,\n    connectionArgs: $connectionArgs,\n    resolve: resolver\n  };\n}\n"]}