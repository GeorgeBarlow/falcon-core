{"version":3,"sources":["../../src/connections/SqliteConnectionValidation.js"],"names":["connection","customJoi","extend","base","joi","string","name","language","file","file_exists","sqlite_valid","rules","validate","params","value","state","options","createError","v","q","existsSync","db","passed","readonly","fileMustExist","pragma","e","close","schema","object","keys","id","required","database","type","errors","abortEarly","error","details","length","errorMessages","map","message","detail","fieldName","context","label","SqliteConnectionValidation"],"mappings":"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","file":"SqliteConnectionValidation.js","sourcesContent":["// @flow\nimport isFilePath from 'is-valid-path';\nimport Joi from 'joi';\nimport fs from 'fs';\nimport Database from 'better-sqlite3';\nimport type {\n  connectionValidationType,\n  connectionType\n} from './Connections';\n\nexport default async function SqliteConnectionValidation(connection: connectionType): Promise<connectionValidationType> {\n  const customJoi = Joi.extend(joi => ({\n    base: joi.string(),\n    name: 'string',\n    language: {\n      file: 'needs to be a file',\n      file_exists: 'does not exist',\n      sqlite_valid: 'is not valid'\n    },\n    rules: [\n      {\n        name: 'file',\n        validate(params, value, state, options) {\n          return !isFilePath(value)\n            ? this.createError('string.file', { v: value, q: params.q }, state, options)\n            : value;\n        }\n      },\n      {\n        name: 'file_exists',\n        validate(params, value, state, options) {\n          return fs.existsSync(value)\n            ? value\n            : this.createError('string.file_exists', { v: value, q: params.q }, state, options);\n        }\n      },\n      {\n        name: 'sqlite_valid',\n        validate(params, value, state, options) {\n          let db;\n          let passed = true;\n          try {\n            db = new Database(value, {\n              readonly: true,\n              fileMustExist: true\n            });\n            if (db.pragma('quick_check', true) !== 'ok') {\n              passed = false;\n            }\n          } catch (e) {\n            passed = false;\n          } finally {\n            if (db) {\n              db.close();\n            }\n          }\n\n          return passed\n            ? value\n            : this.createError(\n              'string.sqlite_valid', {\n                v: value,\n                q: params.q\n              },\n              state,\n              options\n            );\n        }\n      }\n    ]\n  }));\n\n  const schema = customJoi.object().keys({\n    id: customJoi.string().required(),\n    name: customJoi.string().required(),\n    database: customJoi.string().file().file_exists().sqlite_valid()\n      .required(),\n    type: customJoi.string().required()\n  });\n\n  const errors = customJoi.validate(\n    connection,\n    schema,\n    {\n      abortEarly: false\n    }\n  );\n\n  if (errors.error) {\n    if (errors.error.details.length > 0) {\n      return {\n        errorMessages: errors.error.details.map(detail => ({\n          message: detail.message,\n          fieldName: detail.context.label\n        })),\n        passed: false\n      };\n    }\n  }\n\n  return {\n    errorMessages: [],\n    passed: true\n  };\n}\n"]}