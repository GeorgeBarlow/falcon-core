{"version":3,"sources":["../../src/connections/Connections.js"],"names":["FinalStore","process","env","NODE_ENV","require","Connections","store","defaults","connections","validateBeforeCreation","connection","isFilePath","Joi","fs","customJoi","extend","base","joi","string","name","language","file","file_exists","rules","validate","params","value","state","options","createError","v","q","console","log","existsSync","schema","type","object","keys","id","required","database","Error","errors","abortEarly","error","details","create","getAll","push","set","delete","connectionId","filteredConnections","filter","deleteAll","update","connectionToUpdateIndex","findIndex","conn","get","connectionIndex"],"mappings":"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","file":"Connections.js","sourcesContent":["// @flow\n// Manage saved connections to databases. Encrypts passwords\nimport keytar from 'keytar';\nimport Store from 'electron-store';\nimport { error } from 'util';\n\n\ntype connectionValidationType = {\n  errorMessages: Array<{\n    fieldName: string,\n    message: string\n  }>,\n  passed: bool\n};\n\ntype connectionType = {\n  // The internal id for the connection\n  id: string,\n  // The name of the connection\n  name: string,\n  // Which database the connection is for\n  type: 'sqlite' | 'mysql' | 'postgres' | 'mssql',\n  // These are properties that are specific to certain databases.\n  // The pervious properties are required for all databases\n  meta?: {\n    password?: string,\n    database?: string,\n    port?: number,\n    host?: string,\n    username?: string,\n    [otherKeys: string]: string\n  }\n};\n\n// We can't import electron in jest so electron-store won't work.\n// We need to use 'conf' as a drop-in replacement for electron-store\n// in the testing environment\nconst FinalStore = process.env.NODE_ENV === 'test'\n  ? require('conf') // eslint-disable-line\n  : Store;\n\n/**\n * This class is a general manager for falcon database connections.\n * It can be extended to fit the needs of specific databases. For\n * example, if a specific database requires encryption, the .get()\n * method can be modified\n */\nexport default class Connections {\n  store = new FinalStore({\n    defaults: {\n      connections: []\n    }\n  });\n\n  /**\n   * @TODO\n   */\n  async validateBeforeCreation(connection: connectionType): Promise<connectionValidationType> {\n    const isFilePath = await import('is-valid-path');\n    const Joi = await import('joi');\n    const fs = await import('fs');\n\n    const customJoi = Joi.extend(joi => ({\n      base: joi.string(),\n      name: 'string',\n      language: {\n        file: 'needs to be a file',\n        file_exists: 'does not exist'\n      },\n      rules: [\n        {\n          name: 'file',\n          validate(params, value, state, options) {\n            return !isFilePath(value)\n              ? this.createError('string.file', { v: value, q: params.q }, state, options)\n              : value;\n          }\n        },\n        {\n          name: 'file_exists',\n          validate(params, value, state, options) {\n            console.log(value);\n            return fs.existsSync(value)\n              ? this.createError('string.file_exists', { v: value, q: params.q }, state, options)\n              : value;\n          }\n        }\n      ]\n    }));\n\n    const schema = (() => {\n      switch (connection.type) {\n        case 'sqlite': {\n          return customJoi.object().keys({\n            id: customJoi.string().required(),\n            name: customJoi.string().required(),\n            database: customJoi.string().file().file_exists().required(),\n            type: customJoi.string()\n          });\n        }\n        default: {\n          throw new Error(`Unknown database type \"${connection.type}\". This probably means it is not supported`);\n        }\n      }\n    })();\n\n    const errors = customJoi.validate(connection, schema, { abortEarly: false });\n    return errors.error.details;\n  }\n\n  async create(connection: connectionType) {\n    const connections = await this.getAll();\n    connections.push(connection);\n    this.store.set('connections', connections);\n  }\n\n  /**\n   * Delete a connection by it's id\n   */\n  async delete(connectionId: string) {\n    const connections = await this.getAll();\n    const filteredConnections =\n      connections.filter(connection => connection.id !== connectionId);\n    this.store.set('connections', filteredConnections);\n  }\n\n  async deleteAll() {\n    await this.store.set('connections', []);\n  }\n\n  /**\n   * Update a connection by giving a new config\n   */\n  async update(connectionId: string, connection: connectionType): Promise<void> {\n    const connections = await this.getAll();\n    const connectionToUpdateIndex =\n      connections.findIndex(conn => conn.id === connectionId);\n\n    switch (connectionToUpdateIndex) {\n      case -1: {\n        throw new Error(`Connection with id \"${connectionId}\" not found`);\n      }\n      default: {\n        connections[connectionToUpdateIndex] = connection;\n      }\n    }\n\n    this.store.set('connections', connections);\n  }\n\n  async getAll(): Promise<Array<connectionType>> {\n    return this.store.get('connections');\n  }\n\n  async get(connectionId: string): Promise<connectionType> {\n    const connections = await this.getAll();\n    const connectionIndex =\n      connections.findIndex(conn => conn.id === connectionId);\n\n    switch (connectionIndex) {\n      case -1: {\n        throw new Error(`Connection with id \"${connectionId}\" not found`);\n      }\n      default: {\n        return connections[connectionIndex];\n      }\n    }\n  }\n}\n"]}