{"version":3,"sources":["../../src/connections/Connections.js"],"names":["FinalStore","process","env","NODE_ENV","require","Connections","store","defaults","connections","validateBeforeCreation","connection","isFilePath","Joi","fs","Database","customJoi","extend","base","joi","string","name","language","file","file_exists","sqlite_valid","rules","validate","params","value","state","options","createError","v","q","existsSync","db","passed","readonly","fileMustExist","pragma","e","close","schema","type","object","keys","id","required","database","Error","errors","abortEarly","error","details","length","create","getAll","push","set","delete","connectionId","filteredConnections","filter","deleteAll","update","connectionToUpdateIndex","findIndex","conn","get","connectionIndex"],"mappings":"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","file":"Connections.js","sourcesContent":["// @flow\n// Manage saved connections to databases. Encrypts passwords\nimport keytar from 'keytar';\nimport Store from 'electron-store';\nimport { error } from 'util';\n\n\ntype connectionValidationType = {\n  errorMessages: Array<{\n    fieldName: string,\n    message: string\n  }>,\n  passed: bool\n};\n\ntype connectionType = {\n  // The internal id for the connection\n  id: string,\n  // The name of the connection\n  name: string,\n  // Which database the connection is for\n  type: 'sqlite' | 'mysql' | 'postgres' | 'mssql',\n  // These are properties that are specific to certain databases.\n  // The pervious properties are required for all databases\n  meta?: {\n    password?: string,\n    database?: string,\n    port?: number,\n    host?: string,\n    username?: string,\n    [otherKeys: string]: string\n  }\n};\n\n// We can't import electron in jest so electron-store won't work.\n// We need to use 'conf' as a drop-in replacement for electron-store\n// in the testing environment\nconst FinalStore = process.env.NODE_ENV === 'test'\n  ? require('conf') // eslint-disable-line\n  : Store;\n\n/**\n * This class is a general manager for falcon database connections.\n * It can be extended to fit the needs of specific databases. For\n * example, if a specific database requires encryption, the .get()\n * method can be modified\n */\nexport default class Connections {\n  store = new FinalStore({\n    defaults: {\n      connections: []\n    }\n  });\n\n  /**\n   * @TODO\n   */\n  async validateBeforeCreation(connection: connectionType): Promise<connectionValidationType> {\n    const isFilePath = await import('is-valid-path');\n    const Joi = await import('joi');\n    const fs = await import('fs');\n    const Database = await import('better-sqlite3');\n\n    const customJoi = Joi.extend(joi => ({\n      base: joi.string(),\n      name: 'string',\n      language: {\n        file: 'needs to be a file',\n        file_exists: 'does not exist',\n        sqlite_valid: 'is not valid'\n      },\n      rules: [\n        {\n          name: 'file',\n          validate(params, value, state, options) {\n            return !isFilePath(value)\n              ? this.createError('string.file', { v: value, q: params.q }, state, options)\n              : value;\n          }\n        },\n        {\n          name: 'file_exists',\n          validate(params, value, state, options) {\n            return fs.existsSync(value)\n              ? value\n              : this.createError('string.file_exists', { v: value, q: params.q }, state, options);\n          }\n        },\n        {\n          name: 'sqlite_valid',\n          validate(params, value, state, options) {\n            let db;\n            let passed = true;\n            try {\n              db = new Database(value, {\n                readonly: true,\n                fileMustExist: true\n              });\n              if (db.pragma('quick_check', true) !== 'ok') {\n                passed = false;\n              }\n            } catch (e) {\n              passed = false;\n            } finally {\n              if (db) {\n                db.close();\n              }\n            }\n\n            return passed\n              ? value\n              : this.createError('string.sqlite_valid', { v: value, q: params.q }, state, options);\n          }\n        }\n      ]\n    }));\n\n    const schema = (() => {\n      switch (connection.type) {\n        case 'sqlite': {\n          return customJoi.object().keys({\n            id: customJoi.string().required(),\n            name: customJoi.string().required(),\n            database: customJoi.string().file().file_exists().sqlite_valid()\n              .required(),\n            type: customJoi.string().required()\n          });\n        }\n        default: {\n          throw new Error(`Unknown database type \"${connection.type}\". This probably means it is not supported`);\n        }\n      }\n    })();\n\n    const errors = customJoi.validate(connection, schema, { abortEarly: false });\n    if (errors.error) {\n      if (errors.error.details.length > 0) {\n        return errors.error.details;\n      }\n    }\n\n    return [];\n  }\n\n  async create(connection: connectionType) {\n    const connections = await this.getAll();\n    connections.push(connection);\n    this.store.set('connections', connections);\n  }\n\n  /**\n   * Delete a connection by it's id\n   */\n  async delete(connectionId: string) {\n    const connections = await this.getAll();\n    const filteredConnections =\n      connections.filter(connection => connection.id !== connectionId);\n    this.store.set('connections', filteredConnections);\n  }\n\n  async deleteAll() {\n    await this.store.set('connections', []);\n  }\n\n  /**\n   * Update a connection by giving a new config\n   */\n  async update(connectionId: string, connection: connectionType): Promise<void> {\n    const connections = await this.getAll();\n    const connectionToUpdateIndex =\n      connections.findIndex(conn => conn.id === connectionId);\n\n    switch (connectionToUpdateIndex) {\n      case -1: {\n        throw new Error(`Connection with id \"${connectionId}\" not found`);\n      }\n      default: {\n        connections[connectionToUpdateIndex] = connection;\n      }\n    }\n\n    this.store.set('connections', connections);\n  }\n\n  async getAll(): Promise<Array<connectionType>> {\n    return this.store.get('connections');\n  }\n\n  async get(connectionId: string): Promise<connectionType> {\n    const connections = await this.getAll();\n    const connectionIndex =\n      connections.findIndex(conn => conn.id === connectionId);\n\n    switch (connectionIndex) {\n      case -1: {\n        throw new Error(`Connection with id \"${connectionId}\" not found`);\n      }\n      default: {\n        return connections[connectionIndex];\n      }\n    }\n  }\n}\n"]}