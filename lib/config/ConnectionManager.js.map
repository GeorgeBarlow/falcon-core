{"version":3,"sources":["../../src/config/ConnectionManager.js"],"names":["FinalStore","process","env","NODE_ENV","require","ConnectionManager","store","defaults","connections","queries","validateBeforeCreation","connection","type","default","sqliteConnectionValidation","Error","add","rndm","connectionWithDefaults","id","color","validation","errorMessages","length","getAll","push","set","passed","data","remove","connectionId","filteredConnections","filter","removeAll","update","connectionToUpdateIndex","findIndex","conn","get","connectionIndex"],"mappings":"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","file":"ConnectionManager.js","sourcesContent":["// @flow\n// Manage saved connections to databases. Encrypts passwords\nimport Store from 'electron-store';\n\nexport type connectionValidationType = {\n  errorMessages: Array<{\n    fieldName: string,\n    message: string\n  }>,\n  passed: bool,\n  data?: {\n    connection: connectionType\n  }\n};\n\nexport type connectionType = {\n  // The internal id for the connection\n  id: string,\n  // The name of the connection\n  name: string,\n  // The color of the connection\n  color?: string | 'default',\n  // Which database the connection is for\n  type: 'sqlite' | 'mysql' | 'postgres' | 'mssql',\n  // These are properties that are specific to certain databases.\n  // The pervious properties are required for all databases\n  meta?: {\n    password?: string,\n    database?: string,\n    port?: number,\n    host?: string,\n    username?: string,\n    [otherKeys: string]: string\n  }\n};\n\n// We can't import electron in jest so electron-store won't work.\n// We need to use 'conf' as a drop-in replacement for electron-store\n// in the testing environment\nconst FinalStore = process.env.NODE_ENV === 'test'\n  ? require('conf') // eslint-disable-line\n  : Store;\n\n/**\n * This class is a general manager for falcon database connections.\n * It can be extended to fit the needs of specific databases. For\n * example, if a specific database requires encryption, the .get()\n * method can be modified\n */\nexport default class ConnectionManager {\n  /**\n   * @private\n   */\n  store = new FinalStore({\n    defaults: {\n      connections: [],\n      queries: []\n    }\n  });\n\n  /**\n   * @TODO\n   * @private\n   */\n  async validateBeforeCreation(connection: connectionType): Promise<connectionValidationType> {\n    switch (connection.type) {\n      case 'sqlite': {\n        const { default: sqliteConnectionValidation } =\n          await import('./validation/SqliteConnectionValidation.js');\n        return sqliteConnectionValidation(connection);\n      }\n      default: {\n        throw new Error(`Unknown database type \"${connection.type}\". This probably means it is not supported`);\n      }\n    }\n  }\n\n  async add(connection: connectionType): Promise<connectionValidationType> {\n    const rndm = await import('rndm');\n    const connectionWithDefaults = {\n      id: `conn-${rndm(16)}`,\n      color: 'gray',\n      ...connection\n    };\n    const validation = await this.validateBeforeCreation(connectionWithDefaults);\n    if (validation.errorMessages.length > 0) {\n      return validation;\n    }\n\n    const connections = await this.getAll();\n    connections.push(connectionWithDefaults);\n    this.store.set('connections', connections);\n\n    return {\n      errorMessages: [],\n      passed: true,\n      data: {\n        connection: connectionWithDefaults\n      }\n    };\n  }\n\n  /**\n   * Remove a connection by it's id\n   */\n  async remove(connectionId: string) {\n    const connections = await this.getAll();\n    const filteredConnections =\n      connections.filter(connection => connection.id !== connectionId);\n    this.store.set('connections', filteredConnections);\n  }\n\n  async removeAll() {\n    await this.store.set('connections', []);\n  }\n\n  /**\n   * Update a connection by giving a new config\n   */\n  async update(connectionId: string, connection: connectionType): Promise<connectionValidationType> {\n    const connections = await this.getAll();\n    const connectionToUpdateIndex =\n      connections.findIndex(conn => conn.id === connectionId);\n\n    const validation = await this.validateBeforeCreation(connection);\n    if (validation.errorMessages.length > 0) {\n      return validation;\n    }\n\n    switch (connectionToUpdateIndex) {\n      case -1: {\n        throw new Error(`Connection with id \"${connectionId}\" not found`);\n      }\n      default: {\n        connections[connectionToUpdateIndex] = connection;\n      }\n    }\n\n    this.store.set('connections', connections);\n\n    return {\n      errorMessages: [],\n      passed: true,\n      data: {\n        connection\n      }\n    };\n  }\n\n  async getAll(): Promise<Array<connectionType>> {\n    return this.store.get('connections');\n  }\n\n  async get(connectionId: string): Promise<connectionType> {\n    const connections = await this.getAll();\n    const connectionIndex =\n      connections.findIndex(conn => conn.id === connectionId);\n\n    switch (connectionIndex) {\n      case -1: {\n        throw new Error(`Connection with id \"${connectionId}\" not found`);\n      }\n      default: {\n        return connections[connectionIndex];\n      }\n    }\n  }\n}\n"]}