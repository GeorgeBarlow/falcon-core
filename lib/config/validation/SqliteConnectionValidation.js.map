{"version":3,"sources":["../../../src/config/validation/SqliteConnectionValidation.js"],"names":["SqliteConnectionValidation","connection","customJoi","extend","joi","base","string","name","language","file","file_exists","sqlite_valid","rules","validate","params","value","state","options","createError","v","q","existsSync","db","passed","readonly","fileMustExist","pragma","e","close","schema","object","keys","id","required","color","database","type","errors","abortEarly","error","details","length","errorsMessages","map","detail","message","fieldName","context","label","JSON","stringify"],"mappings":";;;;;kBAWwBA,0B;;AAVxB;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AAMe,SAASA,0BAAT,CACbC,UADa,EAEsB;AACnC,QAAMC,YAAY,cAAIC,MAAJ,CAAWC,QAAQ;AACnCC,UAAMD,IAAIE,MAAJ,EAD6B;AAEnCC,UAAM,QAF6B;AAGnCC,cAAU;AACRC,YAAM,oBADE;AAERC,mBAAa,gBAFL;AAGRC,oBAAc;AAHN,KAHyB;AAQnCC,WAAO,CACL;AACEL,YAAM,MADR;AAEEM,eAASC,MAAT,EAAiBC,KAAjB,EAAwBC,KAAxB,EAA+BC,OAA/B,EAAwC;AACtC,eAAO,CAAC,2BAAWF,KAAX,CAAD,GACH,KAAKG,WAAL,CACE,aADF,EAEE,EAAEC,GAAGJ,KAAL,EAAYK,GAAGN,OAAOM,CAAtB,EAFF,EAGEJ,KAHF,EAIEC,OAJF,CADG,GAOHF,KAPJ;AAQD;AAXH,KADK,EAcL;AACER,YAAM,aADR;AAEEM,eAASC,MAAT,EAAiBC,KAAjB,EAAwBC,KAAxB,EAA+BC,OAA/B,EAAwC;AACtC,eAAO,aAAGI,UAAH,CAAcN,KAAd,IACHA,KADG,GAEH,KAAKG,WAAL,CACE,oBADF,EAEE,EAAEC,GAAGJ,KAAL,EAAYK,GAAGN,OAAOM,CAAtB,EAFF,EAGEJ,KAHF,EAIEC,OAJF,CAFJ;AAQD;AAXH,KAdK,EA2BL;AACEV,YAAM,cADR;AAEEM,eAASC,MAAT,EAAiBC,KAAjB,EAAwBC,KAAxB,EAA+BC,OAA/B,EAAwC;AACtC,YAAIK,EAAJ;AACA,YAAIC,SAAS,IAAb;AACA,YAAI;AACFD,eAAK,2BAAaP,KAAb,EAAoB;AACvBS,sBAAU,IADa;AAEvBC,2BAAe;AAFQ,WAApB,CAAL;AAIA,cAAIH,GAAGI,MAAH,CAAU,aAAV,EAAyB,IAAzB,MAAmC,IAAvC,EAA6C;AAC3CH,qBAAS,KAAT;AACD;AACF,SARD,CAQE,OAAOI,CAAP,EAAU;AACVJ,mBAAS,KAAT;AACD,SAVD,SAUU;AACR,cAAID,EAAJ,EAAQ;AACNA,eAAGM,KAAH;AACD;AACF;;AAED,eAAOL,SACHR,KADG,GAEH,KAAKG,WAAL,CACE,qBADF,EAEE;AACEC,aAAGJ,KADL;AAEEK,aAAGN,OAAOM;AAFZ,SAFF,EAMEJ,KANF,EAOEC,OAPF,CAFJ;AAWD;AAhCH,KA3BK;AAR4B,GAAR,CAAX,CAAlB;;AAwEA,QAAMY,SAAS3B,UAAU4B,MAAV,GAAmBC,IAAnB,CAAwB;AACrCC,QAAI9B,UAAUI,MAAV,GAAmB2B,QAAnB,EADiC;AAErC1B,UAAML,UAAUI,MAAV,GAAmB2B,QAAnB,EAF+B;AAGrCC,WAAOhC,UAAUI,MAAV,EAH8B;AAIrC6B,cAAUjC,UACPI,MADO,GAEPG,IAFO,GAGPC,WAHO,GAIPC,YAJO,GAKPsB,QALO,EAJ2B;AAUrCG,UAAMlC,UAAUI,MAAV,GAAmB2B,QAAnB;AAV+B,GAAxB,CAAf;;AAaA,QAAMI,SAASnC,UAAUW,QAAV,CAAmBZ,UAAnB,EAA+B4B,MAA/B,EAAuC;AACpDS,gBAAY;AADwC,GAAvC,CAAf;;AAIA,MAAID,OAAOE,KAAX,EAAkB;AAChB,QAAIF,OAAOE,KAAP,CAAaC,OAAb,CAAqBC,MAArB,GAA8B,CAAlC,EAAqC;AACnC,YAAMC,iBAAiBL,OAAOE,KAAP,CAAaC,OAAb,CAAqBG,GAArB,CAAyBC,WAAW;AACzDC,iBAASD,OAAOC,OADyC;AAEzDC,mBAAWF,OAAOG,OAAP,CAAeC;AAF+B,OAAX,CAAzB,CAAvB;;AAKA,YAAM,6BACH,sBAAqBC,KAAKC,SAAL,CAAeR,cAAf,CAA+B,EADjD,EAEJ,EAAEL,MAAF,EAFI,CAAN;AAID;AACF;AACF","file":"SqliteConnectionValidation.js","sourcesContent":["// @flow\nimport isFilePath from 'is-valid-path';\nimport Joi from 'joi';\nimport fs from 'fs';\nimport Database from 'better-sqlite3';\nimport { FalconError } from '../BaseManager';\nimport type {\n  connectionValidationType,\n  connectionType\n} from '../ConnectionManager';\n\nexport default function SqliteConnectionValidation(\n  connection: connectionType\n): Promise<connectionValidationType> {\n  const customJoi = Joi.extend(joi => ({\n    base: joi.string(),\n    name: 'string',\n    language: {\n      file: 'needs to be a file',\n      file_exists: 'does not exist',\n      sqlite_valid: 'is not valid'\n    },\n    rules: [\n      {\n        name: 'file',\n        validate(params, value, state, options) {\n          return !isFilePath(value)\n            ? this.createError(\n                'string.file',\n                { v: value, q: params.q },\n                state,\n                options\n              )\n            : value;\n        }\n      },\n      {\n        name: 'file_exists',\n        validate(params, value, state, options) {\n          return fs.existsSync(value)\n            ? value\n            : this.createError(\n                'string.file_exists',\n                { v: value, q: params.q },\n                state,\n                options\n              );\n        }\n      },\n      {\n        name: 'sqlite_valid',\n        validate(params, value, state, options) {\n          let db;\n          let passed = true;\n          try {\n            db = new Database(value, {\n              readonly: true,\n              fileMustExist: true\n            });\n            if (db.pragma('quick_check', true) !== 'ok') {\n              passed = false;\n            }\n          } catch (e) {\n            passed = false;\n          } finally {\n            if (db) {\n              db.close();\n            }\n          }\n\n          return passed\n            ? value\n            : this.createError(\n                'string.sqlite_valid',\n                {\n                  v: value,\n                  q: params.q\n                },\n                state,\n                options\n              );\n        }\n      }\n    ]\n  }));\n\n  const schema = customJoi.object().keys({\n    id: customJoi.string().required(),\n    name: customJoi.string().required(),\n    color: customJoi.string(),\n    database: customJoi\n      .string()\n      .file()\n      .file_exists()\n      .sqlite_valid()\n      .required(),\n    type: customJoi.string().required()\n  });\n\n  const errors = customJoi.validate(connection, schema, {\n    abortEarly: false\n  });\n\n  if (errors.error) {\n    if (errors.error.details.length > 0) {\n      const errorsMessages = errors.error.details.map(detail => ({\n        message: detail.message,\n        fieldName: detail.context.label\n      }));\n\n      throw new FalconError(\n        `Failed validation: ${JSON.stringify(errorsMessages)}`,\n        { errors }\n      );\n    }\n  }\n}\n"]}